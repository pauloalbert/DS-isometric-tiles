/*
 * G_Isometric.c
 *
 *  In charge of tile graphics
 */
#include "G_Isometric.h"
typedef enum {
	FACE_FLOOR = 0,
	FACE_WALL_LEFT = 0b01,
	FACE_WALL_RIGHT = 0b10
} BlockFaces;
inline void _setSlice(u16* tiles, int tile, TileSlices slice, u8 color,BlockFaces face){
	tiles[tile] &= ~((SLICE_MASK << slice) | BIT(15));
	tiles[tile] ^= ((face<<3) | color) << slice | BIT(15);
}
inline void _setWhole(u16* tiles, int tile, u8 color_top, BlockFaces face_top, u8 color_middle, BlockFaces face_middle, u8 color_bottom, BlockFaces face_bottom){
	tiles[tile] = BIT(15) | ((face_bottom<<3|color_bottom)<<T_BOTTOM) | ((face_middle<<3|color_middle)<<T_MIDDLE)| ((face_top<<3|color_top)<<T_TOP) ;
}
void ISO_GenerateTiles(u16* tiles, s8* world, u8 world_dim_x, u8 world_dim_y, u8 world_dim_z){
	int i,j,k;

	for(k = 0; k < world_dim_z; k++){
		for(j = 0; j < world_dim_y; j++){
			for(i = 0; i < world_dim_x; i++){

				//if air, skip
				u8 block_type = world[coords_3d(i,j,k,world_dim_x,world_dim_y)];
				if(! block_type) continue;

				//get topleft tile
				int tile = ISO_convertWorldToTile(i,j,k);

				//is this block half shifted down?
				bool is_full = ((i+j)%2 == 0);
				if(is_full){
					//TODO edge case of wrapping, edge case of original tile wrapping
					_setSlice(tiles, tile, T_MIDDLE, block_type, FACE_FLOOR);
					_setSlice(tiles, tile++,T_BOTTOM, block_type,FACE_WALL_LEFT);
					_setSlice(tiles, tile, T_MIDDLE, block_type, FACE_FLOOR);
					_setSlice(tiles, tile, T_BOTTOM, block_type, FACE_WALL_RIGHT);

					tile += TILES_SHAPE_WIDTH - 1;

					_setSlice(tiles, tile,T_TOP, block_type, FACE_WALL_LEFT);
					_setSlice(tiles, tile,T_MIDDLE, block_type, FACE_WALL_LEFT);
					tile += 1;
					_setSlice(tiles, tile,T_TOP, block_type, FACE_WALL_RIGHT);
					_setSlice(tiles, tile,T_MIDDLE, block_type, FACE_WALL_RIGHT);
				}
				else{
					//TODO edge case of wrapping, edge case of original tile wrapping
					_setSlice(tiles, tile++, T_BOTTOM, block_type, FACE_FLOOR); 	//++!
					_setSlice(tiles, tile, T_BOTTOM, block_type, FACE_FLOOR);

					tile += TILES_SHAPE_WIDTH - 1;
					_setWhole(tiles,tile,block_type, FACE_FLOOR, block_type, FACE_WALL_LEFT, block_type, FACE_WALL_LEFT);
					tile += 1;
					_setWhole(tiles,tile,block_type, FACE_FLOOR, block_type, FACE_WALL_RIGHT, block_type, FACE_WALL_RIGHT);
					tile += TILES_SHAPE_WIDTH - 1;
					_setSlice(tiles, tile, T_TOP, block_type, FACE_WALL_LEFT);
					tile += 1;
					_setSlice(tiles, tile, T_TOP, block_type, FACE_WALL_RIGHT);
				}
			}
		}
	}
}

u16 tiles[TILES_SHAPE_WIDTH * TILES_SHAPE_HEIGHT];
void ISO_RenderTiles(s8* world){
	ISO_GenerateTiles(tiles, world, WORLD_DIM_X, WORLD_DIM_Y, WORLD_DIM_Z);
	int i,j;
	for(j = 0; j < TILES_SHAPE_WIDTH*TILES_SHAPE_HEIGHT/1; j++){
		int tile = tiles[j];
		u8 bottom = (tile & (SLICE_MASK<<T_BOTTOM))>> T_BOTTOM;
		u8 middle = (tile & (SLICE_MASK<<T_MIDDLE)) >> T_MIDDLE;
		u8 top = (tile & (SLICE_MASK<<T_TOP)) >> T_TOP;
		if(!tile){
			BG_MAP_RAM(3)[j] = T_FULL;
			continue;
		}

		//How many triangles are the same? (This is how i split the tiles)
		int unique_colors = 3 - ((bottom==middle) + (middle==top||top==bottom));
			//printf("(%d,%d) %d %d %d, %d\n",j%32,j/32,bottom, middle, top,tile);
		//I flip every other tile to create the diamond shapes.
		byte isFlipped = (j%2 == 0 ? BIT(10) : 0);
		byte palette = 0;
		switch(unique_colors){
		case 1:
			//Check if the solid color is a wall or not. see COLOR_PALETTE first row
			palette = ((bottom & 0b11000) == 0 ? bottom : ((bottom & 0b11000)>>3) + (bottom<<1));
			BG_MAP_RAM(3)[j] = isFlipped | T_FULL | palette<<12;
			break;
		case 2:
			break;
		}
	}
}

s16 ISO_convertWorldToTile(u8 px, u8 py, u8 pz){
	int tile = TILES_ORIGIN;

	//get the "floor coordinates" equivalent
	s16 x = px - 2*pz;
	s16 y = py - 2*pz;

	//calculate the tile offset from the origin
	int offset_x = (y - x);
	int offset_y = (x+y)/2;
	tile += (offset_x + TILES_SHAPE_WIDTH * offset_y);

	return tile;
}

/*
 * Gives the bottom left solution.
 * return = (px) | (py << 8);  //pz = 0
 * or return = U16_MAX in case of failure
 *
 * returns the lowest tile affecting this one (the bottom triangle)
 *
 */
u16 ISO_convertTileToWorld(u16 tile);


/* TILES */

u8 TILE_FULL[] = {
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88,
		0x88,0x88,0x88,0x88
};


u8 TILE_ABC_F1F2F3[] = {
		0x11,0x11,0x11,0x22,
		0x11,0x11,0x22,0x22,
		0x11,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x33,0x22,0x22,0x22,
		0x33,0x33,0x22,0x22,
		0x33,0x33,0x33,0x22,
		0x33,0x33,0x33,0x33
};
u8 TILE_ABC_F1F2W2[] = {
		0x22,0x22,0x22,0x44,
		0x22,0x22,0x44,0x44,
		0x22,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x55,0x44,0x44,0x44,
		0x55,0x55,0x44,0x44,
		0x55,0x55,0x55,0x44,
		0x55,0x55,0x55,0x55
};
u8 TILE_ABC_F1W1F2[] = {
		0x44,0x44,0x44,0x55,
		0x44,0x44,0x55,0x55,
		0x44,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x22,0x55,0x55,0x55,
		0x22,0x22,0x55,0x55,
		0x22,0x22,0x22,0x55,
		0x22,0x22,0x22,0x22
};
u8 TILE_ABC_WFF_W2F2F3[] = {
		0x55,0x55,0x55,0x44,
		0x55,0x55,0x44,0x44,
		0x55,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x22,0x44,0x44,0x44,
		0x22,0x22,0x44,0x44,
		0x22,0x22,0x22,0x44,
		0x22,0x22,0x22,0x22
};
u8 TILE_ABC_WFF_W3F2F3[] = {
		0x55,0x55,0x55,0x22,
		0x55,0x55,0x22,0x22,
		0x55,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x44,0x22,0x22,0x22,
		0x44,0x44,0x22,0x22,
		0x44,0x44,0x44,0x22,
		0x44,0x44,0x44,0x44
};
u8 TILE_ABC_WFF_W1F2F3[] = {
		0x55,0x55,0x55,0x22,
		0x55,0x55,0x22,0x22,
		0x55,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x33,0x22,0x22,0x22,
		0x33,0x33,0x22,0x22,
		0x33,0x33,0x33,0x22,
		0x33,0x33,0x33,0x33
};
u8 TILE_ABC_WFF_W1DF3[] = {
		0x55,0x55,0x55,0x77,
		0x55,0x55,0x77,0x77,
		0x55,0x77,0x77,0x77,
		0x77,0x77,0x77,0x77,
		0x33,0x77,0x77,0x77,
		0x33,0x33,0x77,0x77,
		0x33,0x33,0x33,0x77,
		0x33,0x33,0x33,0x33
};
/*Two are same*/
u8 TILE_ABA_F1F2F1[] = {
		0x11,0x11,0x11,0x22,
		0x11,0x11,0x22,0x22,
		0x11,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x11,0x22,0x22,0x22,
		0x11,0x11,0x22,0x22,
		0x11,0x11,0x11,0x22,
		0x11,0x11,0x11,0x11
};
u8 TILE_ABA_F1W1F1[] = {
		0x44,0x44,0x44,0x55,
		0x44,0x44,0x55,0x55,
		0x44,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x44,0x55,0x55,0x55,
		0x44,0x44,0x55,0x55,
		0x44,0x44,0x44,0x55,
		0x44,0x44,0x44,0x44
};
u8 TILE_ABA_W1F1W1[] = {
		0x55,0x55,0x55,0x44,
		0x55,0x55,0x44,0x44,
		0x55,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x55,0x44,0x44,0x44,
		0x55,0x55,0x44,0x44,
		0x55,0x55,0x55,0x44,
		0x55,0x55,0x55,0x55
};

u8 TILE_AAB_F1F1F2[] = {
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x22,0x11,0x11,0x11,
		0x22,0x22,0x11,0x11,
		0x22,0x22,0x22,0x11,
		0x22,0x22,0x22,0x22
};

u8 TILE_AAB_F1F1W1[] = {
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x55,0x44,0x44,0x44,
		0x55,0x55,0x44,0x44,
		0x55,0x55,0x55,0x44,
		0x55,0x55,0x55,0x55
};

u8 TILE_AAB_WWX_W1W1F2[] = {
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x22,0x55,0x55,0x55,
		0x22,0x22,0x55,0x55,
		0x22,0x22,0x22,0x55,
		0x22,0x22,0x22,0x22
};
u8 TILE_AAB_WWX_W1W1F1[] = {
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x44,0x55,0x55,0x55,
		0x44,0x44,0x55,0x55,
		0x44,0x44,0x44,0x55,
		0x44,0x44,0x44,0x44
};
u8 TILE_AAB_WWX_W1W1W2[] = {
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x66,0x55,0x55,0x55,
		0x66,0x66,0x55,0x55,
		0x66,0x66,0x66,0x55,
		0x66,0x66,0x66,0x66
};

u8 TILE_AAB_WWX_W1W1W1B[] = {
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x11,0x55,0x55,0x55,
		0x11,0x11,0x55,0x55,
		0x11,0x11,0x11,0x55,
		0x11,0x11,0x11,0x11
};

u8 TILE_AAB_WWX_W1BW1BW1[] = {
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x55,0x11,0x11,0x11,
		0x55,0x55,0x11,0x11,
		0x55,0x55,0x55,0x11,
		0x55,0x55,0x55,0x55
};
u8 TILE_AAB_DDF2[] = {
		0x77,0x77,0x77,0x77,
		0x77,0x77,0x77,0x77,
		0x77,0x77,0x77,0x77,
		0x77,0x77,0x77,0x77,
		0x22,0x77,0x77,0x77,
		0x22,0x22,0x77,0x77,
		0x22,0x22,0x22,0x77,
		0x22,0x22,0x22,0x22
};

u8 TILE_ABB_F1W1W1[] = {
		0x44,0x44,0x44,0x55,
		0x44,0x44,0x55,0x55,
		0x44,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55,
		0x55,0x55,0x55,0x55
};

u8 TILE_ABB_F1F2F2[] = {
		0x11,0x11,0x11,0x22,
		0x11,0x11,0x22,0x22,
		0x11,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22
};

u8 TILE_ABB_WFF_W2F2F2[] = {
		0x55,0x55,0x55,0x44,
		0x55,0x55,0x44,0x44,
		0x55,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44,
		0x44,0x44,0x44,0x44
};

u8 TILE_ABB_WFF_W1F2F2[] = {
		0x55,0x55,0x55,0x22,
		0x55,0x55,0x22,0x22,
		0x55,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22,
		0x22,0x22,0x22,0x22
};
u8 TILE_ABB_DF2F2[] = {
		0x77,0x77,0x77,0x11,
		0x77,0x77,0x11,0x11,
		0x77,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11,
		0x11,0x11,0x11,0x11
};

//0x0 ALL 	COLORS, 1 PER PALETTE
//0x1-0x3 	PERMUTATION OF FLOORS
//0x4		FLOORS
//0x5		RESPECTIVE WALLS FOR FLOOR 0x4
//0x6		OPPOSITE WALL FOR FLOOR	   0x4
//0x7		WATER
u16 COLOR_PALETTE[] = {
		COLOR_WATER,COLOR_F1, COLOR_F2, COLOR_FS, COLOR_W1A,COLOR_W1B,COLOR_W2A,COLOR_W2B,
		COLOR_F1,	COLOR_F1, COLOR_F2, COLOR_F2, COLOR_FS, COLOR_FS, COLOR_W1A,COLOR_W2A,
		COLOR_F2, 	COLOR_FS, COLOR_F1, COLOR_FS, COLOR_F1, COLOR_F2, COLOR_F2, COLOR_FS,
		COLOR_FS, 	COLOR_F2, COLOR_FS, COLOR_F1, COLOR_F2, COLOR_F1, COLOR_FS, COLOR_F1,
		COLOR_F1,	COLOR_F1, COLOR_F2, COLOR_F2, COLOR_F2, COLOR_F1, COLOR_F1, COLOR_F2,
		COLOR_W1A, 	COLOR_W1A,COLOR_W2A,COLOR_W2A,COLOR_W2B,COLOR_W1B,COLOR_W1B,COLOR_W2B,
		COLOR_W2A,  COLOR_W2B,COLOR_W1A,COLOR_W1B,COLOR_W1A,COLOR_W2B,COLOR_W2A,COLOR_W1B,
		COLOR_WATER,COLOR_WATER,COLOR_WATER,COLOR_WATER,COLOR_WATER,COLOR_WATER,COLOR_WATER,COLOR_WATER
};
void ISO_InitTiles(){
	/* Palette */
	u8 color_offset = 0;
	u8 palette_offset = 0;
	//create the manual list with loops to not have to change the offsets every time.
	for(color_offset = 0; color_offset < 8; color_offset ++){
		for(palette_offset = 0; palette_offset < 8; palette_offset++){
			BG_PALETTE[coords((color_offset+7)%8+1,palette_offset,16)] = COLOR_PALETTE[coords(palette_offset,color_offset,8)];
		}
	}

	/* Tiles */
	dmaCopy(TILE_FULL, &BG_TILE_RAM(0)[T_FULL<<4], 32);

	dmaCopy(TILE_ABA_F1F2F1, &BG_TILE_RAM(0)[T_ABA_F1F2F1<<4], 32);
	dmaCopy(TILE_ABA_F1W1F1, &BG_TILE_RAM(0)[T_ABA_F1W1F1<<4], 32);
	dmaCopy(TILE_ABA_W1F1W1, &BG_TILE_RAM(0)[T_ABA_W1F1W1<<4], 32);

	dmaCopy(TILE_AAB_F1F1F2, &BG_TILE_RAM(0)[T_AAB_F1F1F2<<4], 32);
	dmaCopy(TILE_AAB_DDF2, &BG_TILE_RAM(0)[T_AAB_DDF2<<4], 32);
	dmaCopy(TILE_AAB_F1F1W1, &BG_TILE_RAM(0)[T_AAB_F1F1W1<<4], 32);
	dmaCopy(TILE_AAB_WWX_W1W1F1, &BG_TILE_RAM(0)[T_AAB_WWX_W1W1F1<<4], 32);
	dmaCopy(TILE_AAB_WWX_W1W1F2, &BG_TILE_RAM(0)[T_AAB_WWX_W1W1F2<<4], 32);
	dmaCopy(TILE_AAB_WWX_W1W1W2, &BG_TILE_RAM(0)[T_AAB_WWX_W1W1W2<<4], 32);
	dmaCopy(TILE_AAB_WWX_W1W1W1B, &BG_TILE_RAM(0)[T_AAB_WWX_W1W1W1B<<4], 32);
	dmaCopy(TILE_AAB_WWX_W1BW1BW1, &BG_TILE_RAM(0)[T_AAB_WWX_W1BW1BW1<<4], 32);

	dmaCopy(TILE_ABB_F1F2F2, &BG_TILE_RAM(0)[T_ABB_F1F2F2<<4], 32);
	dmaCopy(TILE_ABB_F1W1W1, &BG_TILE_RAM(0)[T_ABB_F1W1W1<<4], 32);
	dmaCopy(TILE_ABB_WFF_W1F2F2, &BG_TILE_RAM(0)[T_ABB_WFF_W1F2F2<<4], 32);
	dmaCopy(TILE_ABB_WFF_W2F2F2, &BG_TILE_RAM(0)[T_ABB_WFF_W2F2F2<<4], 32);
	dmaCopy(TILE_ABB_DF2F2, &BG_TILE_RAM(0)[T_ABB_DF2F2<<4], 32);

	dmaCopy(TILE_ABC_F1F2F3, &BG_TILE_RAM(0)[T_ABC_F1F2F3<<4], 32);
	dmaCopy(TILE_ABC_F1F2W2, &BG_TILE_RAM(0)[T_ABC_F1F2W2<<4], 32);
	dmaCopy(TILE_ABC_F1W1F2, &BG_TILE_RAM(0)[T_ABC_F1W1F2<<4], 32);
	dmaCopy(TILE_ABC_WFF_W1F2F3, &BG_TILE_RAM(0)[T_ABC_WFF_W1F2F3<<4], 32);
	dmaCopy(TILE_ABC_WFF_W2F2F3, &BG_TILE_RAM(0)[T_ABC_WFF_W2F2F3<<4], 32);
	dmaCopy(TILE_ABC_WFF_W3F2F3, &BG_TILE_RAM(0)[T_ABC_WFF_W3F2F3<<4], 32);
	dmaCopy(TILE_ABC_WFF_W1DF3, &BG_TILE_RAM(0)[T_ABC_WFF_W1DF3<<4], 32);
}
